# Poly1305 MAC tests
# Tests the Poly130-based constant-time implementation

import unittest
import nim_chacha20_poly1305/[common, poly1305]

suite "poly1305":
    test "poly_mac - RFC 7539 Test Vector":
        # Test vector from RFC 7539 Section 2.5.2
        var
            poly_in: Poly1305
            key_in: Key = [
                0x85'u8, 0xd6'u8, 0xbe'u8, 0x78'u8, 0x57'u8, 0x55'u8, 0x6d'u8, 0x33'u8,
                0x7f'u8, 0x44'u8, 0x52'u8, 0xfe'u8, 0x42'u8, 0xd5'u8, 0x06'u8, 0xa8'u8,
                0x01'u8, 0x03'u8, 0x80'u8, 0x8a'u8, 0xfb'u8, 0x0d'u8, 0xb2'u8, 0xfd'u8,
                0x4a'u8, 0xbf'u8, 0xf6'u8, 0xaf'u8, 0x41'u8, 0x49'u8, 0xf5'u8, 0x1b'u8
            ]
            auth_message_in = "Cryptographic Forum Research Group"
            auth_message_in_bytes: array[34, byte]

            tag_expected: Tag = [
                0xa8'u8, 0x06'u8, 0x1d'u8, 0xc1'u8, 0x30'u8, 0x51'u8, 0x36'u8, 0xc6'u8,
                0xc2'u8, 0x2b'u8, 0x8b'u8, 0xaf'u8, 0x0c'u8, 0x01'u8, 0x27'u8, 0xa9'u8
            ]
        copyMem(auth_message_in_bytes[0].addr, auth_message_in[0].addr, 34)

        poly_in.poly1305_init(key_in)
        poly_in.poly1305_update(auth_message_in_bytes)
        let tag = poly_in.poly1305_final()
        check(tag == tag_expected)

    test "poly_mac - RFC 7539 AEAD Test Vector":
        # Test vector from RFC 7539 Section 2.8.2
        var
            poly_in: Poly1305
            otk_in: Key = [
                0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8,
                0x36'u8, 0xe5'u8, 0xf6'u8, 0xb5'u8, 0xc5'u8, 0xe0'u8, 0x60'u8, 0x70'u8, 0xf0'u8, 0xef'u8, 0xca'u8, 0x96'u8, 0x22'u8, 0x7a'u8, 0x86'u8, 0x3e'u8,
            ]
            mac_data = [
                0x41'u8, 0x6e'u8, 0x79'u8, 0x20'u8, 0x73'u8, 0x75'u8, 0x62'u8, 0x6d'u8, 0x69'u8, 0x73'u8, 0x73'u8, 0x69'u8, 0x6f'u8, 0x6e'u8, 0x20'u8, 0x74'u8,
                0x6f'u8, 0x20'u8, 0x74'u8, 0x68'u8, 0x65'u8, 0x20'u8, 0x49'u8, 0x45'u8, 0x54'u8, 0x46'u8, 0x20'u8, 0x69'u8, 0x6e'u8, 0x74'u8, 0x65'u8, 0x6e'u8,
                0x64'u8, 0x65'u8, 0x64'u8, 0x20'u8, 0x62'u8, 0x79'u8, 0x20'u8, 0x74'u8, 0x68'u8, 0x65'u8, 0x20'u8, 0x43'u8, 0x6f'u8, 0x6e'u8, 0x74'u8, 0x72'u8,
                0x69'u8, 0x62'u8, 0x75'u8, 0x74'u8, 0x6f'u8, 0x72'u8, 0x20'u8, 0x66'u8, 0x6f'u8, 0x72'u8, 0x20'u8, 0x70'u8, 0x75'u8, 0x62'u8, 0x6c'u8, 0x69'u8,
                0x63'u8, 0x61'u8, 0x74'u8, 0x69'u8, 0x6f'u8, 0x6e'u8, 0x20'u8, 0x61'u8, 0x73'u8, 0x20'u8, 0x61'u8, 0x6c'u8, 0x6c'u8, 0x20'u8, 0x6f'u8, 0x72'u8,
                0x20'u8, 0x70'u8, 0x61'u8, 0x72'u8, 0x74'u8, 0x20'u8, 0x6f'u8, 0x66'u8, 0x20'u8, 0x61'u8, 0x6e'u8, 0x20'u8, 0x49'u8, 0x45'u8, 0x54'u8, 0x46'u8,
                0x20'u8, 0x49'u8, 0x6e'u8, 0x74'u8, 0x65'u8, 0x72'u8, 0x6e'u8, 0x65'u8, 0x74'u8, 0x2d'u8, 0x44'u8, 0x72'u8, 0x61'u8, 0x66'u8, 0x74'u8, 0x20'u8,
                0x6f'u8, 0x72'u8, 0x20'u8, 0x52'u8, 0x46'u8, 0x43'u8, 0x20'u8, 0x61'u8, 0x6e'u8, 0x64'u8, 0x20'u8, 0x61'u8, 0x6e'u8, 0x79'u8, 0x20'u8, 0x73'u8,
                0x74'u8, 0x61'u8, 0x74'u8, 0x65'u8, 0x6d'u8, 0x65'u8, 0x6e'u8, 0x74'u8, 0x20'u8, 0x6d'u8, 0x61'u8, 0x64'u8, 0x65'u8, 0x20'u8, 0x77'u8, 0x69'u8,
                0x74'u8, 0x68'u8, 0x69'u8, 0x6e'u8, 0x20'u8, 0x74'u8, 0x68'u8, 0x65'u8, 0x20'u8, 0x63'u8, 0x6f'u8, 0x6e'u8, 0x74'u8, 0x65'u8, 0x78'u8, 0x74'u8,
                0x20'u8, 0x6f'u8, 0x66'u8, 0x20'u8, 0x61'u8, 0x6e'u8, 0x20'u8, 0x49'u8, 0x45'u8, 0x54'u8, 0x46'u8, 0x20'u8, 0x61'u8, 0x63'u8, 0x74'u8, 0x69'u8,
                0x76'u8, 0x69'u8, 0x74'u8, 0x79'u8, 0x20'u8, 0x69'u8, 0x73'u8, 0x20'u8, 0x63'u8, 0x6f'u8, 0x6e'u8, 0x73'u8, 0x69'u8, 0x64'u8, 0x65'u8, 0x72'u8,
                0x65'u8, 0x64'u8, 0x20'u8, 0x61'u8, 0x6e'u8, 0x20'u8, 0x22'u8, 0x49'u8, 0x45'u8, 0x54'u8, 0x46'u8, 0x20'u8, 0x43'u8, 0x6f'u8, 0x6e'u8, 0x74'u8,
                0x72'u8, 0x69'u8, 0x62'u8, 0x75'u8, 0x74'u8, 0x69'u8, 0x6f'u8, 0x6e'u8, 0x22'u8, 0x2e'u8, 0x20'u8, 0x53'u8, 0x75'u8, 0x63'u8, 0x68'u8, 0x20'u8,
                0x73'u8, 0x74'u8, 0x61'u8, 0x74'u8, 0x65'u8, 0x6d'u8, 0x65'u8, 0x6e'u8, 0x74'u8, 0x73'u8, 0x20'u8, 0x69'u8, 0x6e'u8, 0x63'u8, 0x6c'u8, 0x75'u8,
                0x64'u8, 0x65'u8, 0x20'u8, 0x6f'u8, 0x72'u8, 0x61'u8, 0x6c'u8, 0x20'u8, 0x73'u8, 0x74'u8, 0x61'u8, 0x74'u8, 0x65'u8, 0x6d'u8, 0x65'u8, 0x6e'u8,
                0x74'u8, 0x73'u8, 0x20'u8, 0x69'u8, 0x6e'u8, 0x20'u8, 0x49'u8, 0x45'u8, 0x54'u8, 0x46'u8, 0x20'u8, 0x73'u8, 0x65'u8, 0x73'u8, 0x73'u8, 0x69'u8,
                0x6f'u8, 0x6e'u8, 0x73'u8, 0x2c'u8, 0x20'u8, 0x61'u8, 0x73'u8, 0x20'u8, 0x77'u8, 0x65'u8, 0x6c'u8, 0x6c'u8, 0x20'u8, 0x61'u8, 0x73'u8, 0x20'u8,
                0x77'u8, 0x72'u8, 0x69'u8, 0x74'u8, 0x74'u8, 0x65'u8, 0x6e'u8, 0x20'u8, 0x61'u8, 0x6e'u8, 0x64'u8, 0x20'u8, 0x65'u8, 0x6c'u8, 0x65'u8, 0x63'u8,
                0x74'u8, 0x72'u8, 0x6f'u8, 0x6e'u8, 0x69'u8, 0x63'u8, 0x20'u8, 0x63'u8, 0x6f'u8, 0x6d'u8, 0x6d'u8, 0x75'u8, 0x6e'u8, 0x69'u8, 0x63'u8, 0x61'u8,
                0x74'u8, 0x69'u8, 0x6f'u8, 0x6e'u8, 0x73'u8, 0x20'u8, 0x6d'u8, 0x61'u8, 0x64'u8, 0x65'u8, 0x20'u8, 0x61'u8, 0x74'u8, 0x20'u8, 0x61'u8, 0x6e'u8,
                0x79'u8, 0x20'u8, 0x74'u8, 0x69'u8, 0x6d'u8, 0x65'u8, 0x20'u8, 0x6f'u8, 0x72'u8, 0x20'u8, 0x70'u8, 0x6c'u8, 0x61'u8, 0x63'u8, 0x65'u8, 0x2c'u8,
                0x20'u8, 0x77'u8, 0x68'u8, 0x69'u8, 0x63'u8, 0x68'u8, 0x20'u8, 0x61'u8, 0x72'u8, 0x65'u8, 0x20'u8, 0x61'u8, 0x64'u8, 0x64'u8, 0x72'u8, 0x65'u8,
                0x73'u8, 0x73'u8, 0x65'u8, 0x64'u8, 0x20'u8, 0x74'u8, 0x6f'u8,
            ]
            tag_expected: Tag = [
                0x36'u8, 0xe5'u8, 0xf6'u8, 0xb5'u8, 0xc5'u8, 0xe0'u8, 0x60'u8, 0x70'u8, 0xf0'u8, 0xef'u8, 0xca'u8, 0x96'u8, 0x22'u8, 0x7a'u8, 0x86'u8, 0x3e'u8,
            ]
        poly_in.poly1305_init(otk_in)
        poly_in.poly1305_update(mac_data)
        let tag = poly_in.poly1305_final()
        check(tag == tag_expected)

    test "poly1305_verify - constant time comparison":
        var tag1: Tag = [0x01'u8, 0x02'u8, 0x03'u8, 0x04'u8, 0x05'u8, 0x06'u8, 0x07'u8, 0x08'u8,
                         0x09'u8, 0x0a'u8, 0x0b'u8, 0x0c'u8, 0x0d'u8, 0x0e'u8, 0x0f'u8, 0x10'u8]
        var tag2 = tag1
        var tag3: Tag = [0x00'u8, 0x02'u8, 0x03'u8, 0x04'u8, 0x05'u8, 0x06'u8, 0x07'u8, 0x08'u8,
                         0x09'u8, 0x0a'u8, 0x0b'u8, 0x0c'u8, 0x0d'u8, 0x0e'u8, 0x0f'u8, 0x10'u8]

        check(poly1305_verify(tag1, tag2) == true)
        check(poly1305_verify(tag1, tag3) == false)

    test "poly1305 - streaming update":
        # Test that multiple updates produce same result as single update
        var key: Key = [
            0x85'u8, 0xd6'u8, 0xbe'u8, 0x78'u8, 0x57'u8, 0x55'u8, 0x6d'u8, 0x33'u8,
            0x7f'u8, 0x44'u8, 0x52'u8, 0xfe'u8, 0x42'u8, 0xd5'u8, 0x06'u8, 0xa8'u8,
            0x01'u8, 0x03'u8, 0x80'u8, 0x8a'u8, 0xfb'u8, 0x0d'u8, 0xb2'u8, 0xfd'u8,
            0x4a'u8, 0xbf'u8, 0xf6'u8, 0xaf'u8, 0x41'u8, 0x49'u8, 0xf5'u8, 0x1b'u8
        ]

        let message = "Cryptographic Forum Research Group"
        var msg_bytes: array[34, byte]
        copyMem(msg_bytes[0].addr, message[0].unsafeAddr, 34)

        # Single update
        var poly1: Poly1305
        poly1.poly1305_init(key)
        poly1.poly1305_update(msg_bytes)
        let tag1 = poly1.poly1305_final()

        # Multiple updates (byte by byte)
        var poly2: Poly1305
        poly2.poly1305_init(key)
        for i in 0..<34:
            poly2.poly1305_update([msg_bytes[i]])
        let tag2 = poly2.poly1305_final()

        # Multiple updates (chunks)
        var poly3: Poly1305
        poly3.poly1305_init(key)
        poly3.poly1305_update(msg_bytes[0..<10])
        poly3.poly1305_update(msg_bytes[10..<20])
        poly3.poly1305_update(msg_bytes[20..<34])
        let tag3 = poly3.poly1305_final()

        check(tag1 == tag2)
        check(tag1 == tag3)

    test "poly1305 - empty message":
        var key: Key = [
            0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8,
            0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8,
            0x01'u8, 0x02'u8, 0x03'u8, 0x04'u8, 0x05'u8, 0x06'u8, 0x07'u8, 0x08'u8,
            0x09'u8, 0x0a'u8, 0x0b'u8, 0x0c'u8, 0x0d'u8, 0x0e'u8, 0x0f'u8, 0x10'u8
        ]

        var poly: Poly1305
        poly.poly1305_init(key)
        # No update - empty message
        let tag = poly.poly1305_final()

        # With r=0, tag should equal s
        let expected: Tag = [
            0x01'u8, 0x02'u8, 0x03'u8, 0x04'u8, 0x05'u8, 0x06'u8, 0x07'u8, 0x08'u8,
            0x09'u8, 0x0a'u8, 0x0b'u8, 0x0c'u8, 0x0d'u8, 0x0e'u8, 0x0f'u8, 0x10'u8
        ]
        check(tag == expected)

    test "poly1305 - all 0xFF bytes (edge case near modulus)":
        # Test with all 0xFF bytes which creates large values that test reduction logic
        var key: Key = [
            0x01'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8,
            0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8,
            0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8,
            0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8
        ]

        # 16 bytes of 0xFF creates a large accumulator value
        var all_ff: array[16, byte]
        for i in 0..15:
            all_ff[i] = 0xFF

        var poly: Poly1305
        poly.poly1305_init(key)
        poly.poly1305_update(all_ff)
        let tag = poly.poly1305_final()

        # Verify tag is computed (non-zero check for valid computation)
        var nonzero = false
        for b in tag:
            if b != 0:
                nonzero = true
                break
        check(nonzero)

    test "poly1305 - multiple blocks of 0xFF":
        # Test with multiple 16-byte blocks of 0xFF to exercise carry propagation
        var key: Key = [
            0x02'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8,
            0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8,
            0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8,
            0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8
        ]

        var data: array[64, byte]
        for i in 0..63:
            data[i] = 0xFF

        var poly: Poly1305
        poly.poly1305_init(key)
        poly.poly1305_update(data)
        let tag = poly.poly1305_final()

        # Should produce consistent results
        var poly2: Poly1305
        poly2.poly1305_init(key)
        poly2.poly1305_update(data[0..<32])
        poly2.poly1305_update(data[32..<64])
        let tag2 = poly2.poly1305_final()

        check(tag == tag2)

    test "poly1305 - wrap around test (values near 2^130-5)":
        # This test uses specific inputs designed to test modular reduction
        # Key with r = 0x0ffffffc0ffffffc0ffffffc0fffffff (max after clamping)
        var key: Key = [
            0xFF'u8, 0xFF'u8, 0xFF'u8, 0x0F'u8, 0xFC'u8, 0xFF'u8, 0xFF'u8, 0x0F'u8,
            0xFC'u8, 0xFF'u8, 0xFF'u8, 0x0F'u8, 0xFC'u8, 0xFF'u8, 0xFF'u8, 0x0F'u8,
            0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8,
            0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8, 0x00'u8
        ]

        var data: array[32, byte]
        for i in 0..31:
            data[i] = 0xFF

        var poly: Poly1305
        poly.poly1305_init(key)
        poly.poly1305_update(data)
        let tag = poly.poly1305_final()

        # Verify it completes without overflow/crash and produces consistent output
        var poly2: Poly1305
        poly2.poly1305_init(key)
        poly2.poly1305_update(data)
        let tag2 = poly2.poly1305_final()

        check(tag == tag2)

    test "poly1305 - partial block sizes":
        # Test various partial block sizes to ensure padding is correct
        var key: Key = [
            0x85'u8, 0xd6'u8, 0xbe'u8, 0x78'u8, 0x57'u8, 0x55'u8, 0x6d'u8, 0x33'u8,
            0x7f'u8, 0x44'u8, 0x52'u8, 0xfe'u8, 0x42'u8, 0xd5'u8, 0x06'u8, 0xa8'u8,
            0x01'u8, 0x03'u8, 0x80'u8, 0x8a'u8, 0xfb'u8, 0x0d'u8, 0xb2'u8, 0xfd'u8,
            0x4a'u8, 0xbf'u8, 0xf6'u8, 0xaf'u8, 0x41'u8, 0x49'u8, 0xf5'u8, 0x1b'u8
        ]

        # Test sizes 1 through 17 bytes (partial, full, and partial+1)
        for size in 1..17:
            var data = newSeq[byte](size)
            for i in 0..<size:
                data[i] = byte(i + 1)

            var poly: Poly1305
            poly.poly1305_init(key)
            poly.poly1305_update(data)
            let tag = poly.poly1305_final()

            # Verify non-zero tag
            var nonzero = false
            for b in tag:
                if b != 0:
                    nonzero = true
                    break
            check(nonzero)

    test "poly1305 - finalize clears state":
        var key: Key = [
            0x85'u8, 0xd6'u8, 0xbe'u8, 0x78'u8, 0x57'u8, 0x55'u8, 0x6d'u8, 0x33'u8,
            0x7f'u8, 0x44'u8, 0x52'u8, 0xfe'u8, 0x42'u8, 0xd5'u8, 0x06'u8, 0xa8'u8,
            0x01'u8, 0x03'u8, 0x80'u8, 0x8a'u8, 0xfb'u8, 0x0d'u8, 0xb2'u8, 0xfd'u8,
            0x4a'u8, 0xbf'u8, 0xf6'u8, 0xaf'u8, 0x41'u8, 0x49'u8, 0xf5'u8, 0x1b'u8
        ]

        var poly: Poly1305
        poly.poly1305_init(key)
        poly.poly1305_update(cast[seq[byte]]("test"))
        discard poly.poly1305_final()

        # Finalize should clear sensitive state
        poly.poly1305_finalize()

        # Verify r, s, a are all zeroed
        for i in 0..4:
            check(poly.r.limbs[i] == 0)
            check(poly.s.limbs[i] == 0)
            check(poly.a.limbs[i] == 0)
